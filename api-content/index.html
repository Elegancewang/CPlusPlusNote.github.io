{"posts":[{"title":"Linux添加网卡","content":"Debian/Ubuntu系列 方法一： sudo ifconfig eth0:0 192.168.1.63 up eth0网卡上创建一个叫eth0:0的虚拟网卡,他的地址是:192.168.1.63 如果不想要这个虚拟网卡了,可以使用如下命令删除: sudo ifconfig eth0:0 down 方法二： vim /etc/network/interfaces 添加并保存例如以下内容： auto eth0:0 iface eth0:0 inet static address 192.168.1.63 netmask 255.255.255.0 network 192.168.1.1 broadcast 192.168.1.255 重启网卡生效 /etc/init.d/networking restart ","link":"https://elegancewang.github.io/CPlusPlusNote.github.io/post/linux-tian-jia-wang-qia/"},{"title":"TC(Traffic Control)","content":" Linux中的流量控制 1. TC原理 Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。 接收包从输入接口进来后，经过流量限制丢弃不符合规定的数据包，由输入多路分配器进行判断选择： 如果接收包的目的主机是本主机，那么将该包送给上层处理，否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。 转发块同时也接收本主机上层(TCP、UDP等)产生的包，通过查看路由表，决定所处理包的下一跳。 然后，对包进行排列以便将它们送到输出接口。 一般只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。 2. 规则 2.1 队列（Queues） 和排队规则（Queueing Disciplines） 通过对包进行排队（queuing），我们可以决定数据的发送方式（the way in which data is SENT）。但理解下面这一点非常重要：我们只能对发送（transmit）的数据进行整形（shape the data）。 互联网的工作机制决定了接收端无法直接控制发送端的行为。这就像你家的 （实体！）邮箱一样：除非能联系到所有人（告诉他们未经同意不要寄信给你），否则 你无法控制别人寄多少东西过来。😉 但与实际生活不同的是，互联网基于 TCP/IP 协议栈，这多少会带来一些帮助。TCP/IP 无法提前知道两台主机之间的网络带宽，因此开始时它会以越来越快的速度发送数据（慢启 动），直到开始出现丢包，这时它知道已经没有可用空间来存储这些待发送的包了，因此就会 降低发送速度。TCP/IP 的实际工作过程比这个更智能一点，我们后面会再讨论。 这就好比你留下一半的信件在实体邮箱里不取，期望别人知道这个状况后会停止给你寄新的信件。 但不幸的是，这种方式只对互联网管用，对你的实体邮箱无效 😃 如果内网有一台路由器，你希望限制某几台主机的下载速度，那你应该找到发送数据到 这些主机的路由器内部接口（inner interface of your router），然后在这些 路由器内部接口上做 整流（traffic shaping，流量整形）。 此外，还要确保链路瓶颈（bottleneck of the link）也在你的控制范围内。例如，如果网 卡是 100Mbps，但路由器的链路带宽是 256Kbps，那首先应该确保不要发送过多数据给路由器，因为它可能扛不住。否则，链路控制和带宽整形的决定权就不在主机侧而到路由器侧了。要达到限速目的，我们需要对“发送队列”有完全的把控（”own the queue”），这里的“发送队列”也就是整条链路上最慢的一段（slowest link in the chain）。 幸运的是，大多数情况下这个条件都是能满足的。 2.2 Simple， classless qdisc（简单、不分类排队规则） 如前所述，排队规则（queueing disciplines）改变了数据的发送方式。 不分类（或称无类别）排队规则（classless queueing disciplines）可以对某个网络 接口（interface）上的所有流量进行无差别整形。包括对数据进行： 重新调度（reschedule） 增加延迟（delay） 丢弃（drop） 与 classless qdisc 对应的是 classful qdisc，即有类别（或称分类别）排队规则，后者是一个排队规则中又包含其他排队规则（qdisc-containing-qdiscs）！😮 先理解了 classless qdisc，才能理解 classful qdisc。 目前最常用的 classless qdisc 是 pfifo_fast qdisc，这也是默认排队规则。 这也解释了为什么这些高级功能如此健壮：本质上来说，它们只不过是“另一个队列”而 已（nothing more than ‘just another queue’）。 每种队列都有自己的优缺点。其中一些可能测试的并不全面。 2.2 pfifo_fast（先入先出队列） 如名字所示，这是一个先入先出队列（First In, First Out），因此对所有包都一视同仁。 pfifo_fast 有三个所谓的 “band”（可理解为三个队列），编号分别为 0、1、2： 每个 band 上分别执行 FIFO 规则。 如果 band 0 有数据，就不会处理 band 1；同理，band 1 有数据时， 不会去处理 band 2。 内核会检查数据包的 TOS 字段，将**“最小延迟”的包放到 band 0**。 不要将 pfifo_fast qdisc 与后面介绍的 PRIO qdisc 混淆，后者是 classful 的！ 虽然二者行为类似，但 pfifo_fast 是无类别的，这意味你无法通过 tc 命令向 pfifo_fast 内添加另一个 qdisc。 2.2.1 参数与用法 pfifo_fast qdisc 默认配置是写死的（the hardwired default），因此无法更改。 下面介绍这份写死的配置是什么样的。 priomap priomap 决定了如何将内核设置的 packet priority 映射到 band。priority 位于包的 TOS 字段： 0 1 2 3 4 5 6 7 +-----+-----+-----+-----+-----+-----+-----+-----+ | | | | | PRECEDENCE | TOS | MBZ | | | | | +-----+-----+-----+-----+-----+-----+-----+-----+s TOS 字段占用 4 个比特，各 bit 含义如下： Binary Decimcal Meaning ----------------------------------------- 1000 8 Minimize delay (md) 0100 4 Maximize throughput (mt) 0010 2 Maximize reliability (mr) 0001 1 Minimize monetary cost (mmc) 0000 0 Normal Service tcpdump -vv 会打印包的 TOS 字段，其中的 TOS 值对应下面的第一列： TOS Bits Means Linux Priority Band ------------------------------------------------------------ 0x0 0 Normal Service 0 Best Effort 1 0x2 1 Minimize Monetary Cost 1 Filler 2 0x4 2 Maximize Reliability 0 Best Effort 1 0x6 3 mmc+mr 0 Best Effort 1 0x8 4 Maximize Throughput 2 Bulk 2 0xa 5 mmc+mt 2 Bulk 2 0xc 6 mr+mt 2 Bulk 2 0xe 7 mmc+mr+mt 2 Bulk 2 0x10 8 Minimize Delay 6 Interactive 0 0x12 9 mmc+md 6 Interactive 0 0x14 10 mr+md 6 Interactive 0 0x16 11 mmc+mr+md 6 Interactive 0 0x18 12 mt+md 4 Int. Bulk 1 0x1a 13 mmc+mt+md 4 Int. Bulk 1 0x1c 14 mr+mt+md 4 Int. Bulk 1 0x1e 15 mmc+mr+mt+md 4 Int. Bulk 1 第二列是对应的十进制表示，第三列是对应的含义。例如，15 表示这个包期望 Minimal Monetary Cost + Maximum Reliability + Maximum Throughput + Minimum Delay。我把这样的包称为“荷兰包”（a ‘Dutch Packet’。荷兰人比较 节俭/抠门，译注）。第四列是对应到 Linux 内核的优先级；最后一列是 映射到的 band，从命令行输出看，形式为： 1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1 例如，priority 4 会映射到 band 1。priomap 还能列出 priority &gt; 7 的那些 不是由 TOS 映射、而是由其他方式设置的优先级。例如，下表列出了应用（application）是如何设置它们的 TOS 字段的，来自 RFC 1349（更多信息可阅读全文) TELNET 1000 (minimize delay) FTP Control 1000 (minimize delay) Data 0100 (maximize throughput) TFTP 1000 (minimize delay) SMTP Command phase 1000 (minimize delay) DATA phase 0100 (maximize throughput) DNS UDP Query 1000 (minimize delay) TCP Query 0000 Zone Transfer 0100 (maximize throughput) NNTP 0001 (minimize monetary cost) ICMP Errors 0000 Requests 0000 (mostly) Responses &lt;same as request&gt; (mostly) txqueuelen 发送队列长度，是一个网络接口（interface）参数，可以用 ifconfig 命令设置。例 如，ifconfig eth0 txqueuelen 10。 tc 命令无法修改这个值。 2.3 TBF（Token Bucket Filter，令牌桶过滤器） ","link":"https://elegancewang.github.io/CPlusPlusNote.github.io/post/tc traffic-control/"},{"title":"WebRTC 环境配置（Windows 平台）","content":"万事开头难啊，webRTC配置过程中遇到的问题多种多样，有些问题很难搜索到，因此我记录下来供自己参考。 写在前面的话 鉴于WebRTC更新太快，所以网上很多编译方法都失效了，所以如果你看到是几年前的文章，就没必要较真了。本文写作时间为2020年9月16日，WebRTC为当前最新版本。请诸君参考。（另，本人所在地为HK，因此不需要稳定的梯子，希望大家能找到稳定的梯子。） 1.准备 a) Win 10 64bit 1909 b) Visual Studio 2019 Community 16.7.30503.244 c) Windows 10 SDK Windows 10.0.19041.1 d) Python Python 3.8.5 64bit，编译过程中需添加到Path环境变量 f) depot_tools depot_tools是包含下载、编译的相关工具，需要先下载并配置它，才能继续后面的操作。 下载地址:depot_tools 下载后解压，并将解压好的depot_tools目录添加到path系统环境变量中，如下图所示： 2 环境变量配置 有大量的环境变量需要配置，如果在cmd中set需要保持该窗口。一般在系统环境变量编辑里比较简单方便。 最开始我的设置如下： DEPOT_TOOLS_UPDATE=0 #不更新depot_tools DEPOT_TOOLS_WIN_TOOLCHAIN=0 #编译时使用本机VS工具链 GYP_MSVS_VERSION = 2019 #指定VS版本 GYP_MSVS_OVERRIDE_PATH = C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community #vs安装路径，替换成自己的 GYP_GENERATORS=msvs-ninja,ninja #使用ninja编译 Error depot_tools/python3_bin_reldir.txt: No such file or directory failed to determine Python version 我认为是环境变量阻止了其在Windows下的引导，因此删去DEPOT_TOOLS_UPDATE=0 的环境变量即可. 3.获取WebRTC源码 接着执行gclient命令，安装编译需要用到的一些工具，比如git以及python。 其他的环境变量我们已经在前文设置，无需通过cmd进行设置，这是为了我自己的方便，如果对于环境变量有要求，请在cmd自行设置，例： set vs2019_install=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community set GYP_MSVS_OVERRIDE_PATH=C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community set GYP_GENERATORS=msvs-ninja,ninja # 告诉depot_tools使用我们本机的VS进行编译 set DEPOT_TOOLS_WIN_TOOLCHAIN=0 然后cd到要放源码的地方（要遵守前面说的磁盘要求），执行： mkdir webrtc-checkout cd webrtc-checkout fetch --nohooks webrtc gclient sync 这一过程的时间比较长，包括源码以及一些测试的音视频文件资源等。如果没有稳定快速的梯子需要等待较长时间。 如果因为网络等原因中断了，就再执行gclient sync。如果这一步一直卡着不动，可以执行ctrl+c，然后执行gclient sync。 4.编译 生成VS2019工程文件： cd src gn gen --ide=vs out/Default 可以在src\\out\\Default\\ 下得到 all.sln解决方案文件。 如果不想使用默认编译参数，可以使用gn args out/Default --list查看当前编译参数，通过类似如下方式设置： gn gen --ide=vs out/Default --args=“use_rtti=true is_clang=false rtc_build_tools=false rtc_include_tests=false rtc_build_examples=false” 接着执行编译命令： ninja -C out/Default 代码更新 git checkout master git pull origin master gclient sync 引用WebRTC库 WebRTC编译后会在src\\out\\Default\\obj目录下生成整个WebRTC工程的静态库：webrtc.lib，链接下这个就可以了。 ","link":"https://elegancewang.github.io/CPlusPlusNote.github.io/post/webrtc-huan-jing-pei-zhi/"},{"title":"C++学习笔记","content":" Chapter 8 指针、引用 指针—— 存储内存地址 变量 ——占用空间、声明、初始化（否则值为随机） 8.1 运算符 1.1 使用引用运算符（&amp;）获取变量地址 e.g. Varname —— 变量 &amp;Varname —— 存储该变量内存地址 1.2 使用接触引用运算符（*） 以此访问包含地址的值 e.g. 有合法指针——pData 那么该指针地址处存储的值可用 *pData 来获取 1.3 sizeof() 用于指针时，结果取决于编译器及针对的操作系统，与指针变量无关。 8.2 动态内存分配 1. 关键字new &amp; delete 动态分配和释放内存 new分配新的内存块，若成功，返回一个指针，指向新分配的内存，否则引发异常（使用时，指定数据类型分配内存） Type* Pointer = new Type; Type* Pointer = new Type[ Num Elements ]; e.g. int * pNumber = new int; int * pNumber = new int[ 10 ]; 注 ：请求分配内存并不保证请求能够得到满足，取决于系统状态机内存资源的可用性。 使用关键字 new 分配的内存最终使用对应的关键字 delete 释放 Type* Pointer = new Type; delete Pointer; 或 Type* Pointer = new Type[ Num Elements ]; delete [] Pointer; 2. 递增（++）、递减（--）运算符作用于指针的结果 对指针执行递增 / 递减， 指向的是内存中相邻的值，而不是相邻的字节（除非值的长度刚好1字节，例如char） Type * pType = Address; ++pType --&gt; Adress + sizeof( Type ) 3. 关键字const作用于指针 const指针有三种： a ）指针直线的数据为常量，不可修改，但可以修改包含的地址（指针可指向其他地址） b ) 指针包含地址为常量，不能修改，可以修改数据 c ) 最为严格的情况，地址及值均为常量，均不可修改，但更易于维护。 4. 将指针传递给函数 将内存空间传递给函数，其中可包含值，可包含结果 注意传入的数据是否需要修改或者经过计算。 5. 数组与指针 可以将数组变量赋值给类型相同的指针。 8.3 常见错误 1.内存泄露 常见原因是未正确释放内存 2.指向无效的内存单元 无效指针 3.悬浮指针 亦可称之为迷途/失控指针 为便面此类问题，初始化/释放指针后将其置为NULL，并在解除引用前（使用关键字 ** * **）检查其是否有效。 8.4 编程实践 Step1 初始化指针变量 step2 使用前判断指针是否为NULL——&gt;异常处理，在new（创建指针）失败时妥善退出 Step3 仅在其有效时使用 Step4 new之后必用关键字delete释放内存，且delete后不再访问该指针 8.5 引用（&amp;） 引用是变量的别名（相应变量的的另一个名字，指向相同的内存单元） VarType Original = Value; VarType &amp; ReferenceVariable = Original; 1.引用的用处 避免了传参时因参数占用内存过大，复制时也会开销很大。 2. const 用于引用 禁止通过引用修改其指向的变量的值。 const引用参数不能作用于左值 3. 按引用向函数传递参数 可避免将形参复制给形参，从而极大提高性能。然而，让被调用的函数直接使用调用函数栈时，确保被调用函数不能修改调用函数中的变量很重要。因此，可将引用声明为const Chapter 9 类和对象 9.1 类和对象简述 1. 类的声明 关键字 class 依次包含类名、成员属性、方法（属于类成员的函数）及结尾分号（;） 即通过关键字class创建数据类型，并封装属性。 &quot;封装&quot; 将数据及使用它们的方法进行逻辑编组 2.实例化对象 在使用时，根据类实例化一个对象，通过对象访问成员方法及属性。 class Human { string Name; string DateofBirth; void Talk( string TexttoTalk ); }; 那么实例化一个对象Tom //方法一 Human Tom; //方法二 Human* pAnotherHuman = new Human( ); delete pAnotherHuman; 3.通过句点运算符（.）访问成员 句点运算符（.）用于访问对象的属性。这同样适用于方法。 Human Tom; Tom. DateofBirth = &quot;1970&quot; ; Huamn* pTom = new Human(); (*pTom).IntroduceSelf();//使用间接运算符（*）获取对象，再使用句点运算符来访问成员。 4. 使用指针运算符访问成员（-&gt;） 若对象使用new实例化或有指向对象的指针，则可以使用 **指针运算符（-&gt;）**来访问成员属性和方法。 Chapter 11 ** 11.1. 多态基础 1.1 类之间存在层次结构，类是通过继承相关联时，通过多态来表示。 多态意味着调用成员函数时，根据函数的对象类型执行不同的方法。（而不是调用预设的基类中的函数方法），即表现实际类型。 1.2 使用虚函数实现多态行为 将基类中方法声明为虚函数，使用关键字 virtual， 确保编译器调用覆盖版本（子类、派生类）。 多态行为 将派生类对象视为几类对象，并执行派生类的函数（方法）实现。 1.3 为何需要虚构造函数 除了需要使用派生类对象，还需要避免计算机资源未释放、内存泄露等问题（即将实例化的派生类对象，将其值赋给基类当做指针，并通过该指针调用 delete， 将不会调用派生类的析构函数） **⬇** 那么将析构函数声明为虚函数，确保通过基类指针调用delete时，不会调用派生类析构函数 class Base { public: virtual ~Base() }; auto 关键字 利用auto关键字，通过编译器检查变量的初始值，并将该变量类型设置为该返回值的类型。能够简化编码工作。 std::vector&lt;int&gt; MyNumbers; //常规 for (vector&lt;int&gt;::const_iterator Iterator = MyNumbers.begin(); Iterator &lt; MyNumbers.end(); ++Iterator ) std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;; //利用auto关键字 for (auto Iterator = MyNumbers.begin(); Iterator &lt; MyNumbers.end(); ++Iterator ) std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;; ** ","link":"https://elegancewang.github.io/CPlusPlusNote.github.io/post/learnC/"},{"title":"关于","content":" 欢迎来到我的小站呀，很高兴遇见你！🤝 #KTBFFH 💙 CHELSEA 🏠 关于本站 重新开始学习计算机语言， 👨‍💻 博主是谁 ⛹ 兴趣爱好 CHELSEA、DOTA 📬 联系我呀 githubwrz@163.com ","link":"https://elegancewang.github.io/CPlusPlusNote.github.io/post/about/"}]}