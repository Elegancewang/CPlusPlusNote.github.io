<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://elegancewang.github.io/CPlusPlusNote.github.io</id>
    <title>Renzo&apos;s Blog</title>
    <updated>2020-11-09T18:12:29.905Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://elegancewang.github.io/CPlusPlusNote.github.io"/>
    <link rel="self" href="https://elegancewang.github.io/CPlusPlusNote.github.io/atom.xml"/>
    <logo>https://elegancewang.github.io/CPlusPlusNote.github.io/images/avatar.png</logo>
    <icon>https://elegancewang.github.io/CPlusPlusNote.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Renzo&apos;s Blog</rights>
    <entry>
        <title type="html"><![CDATA[Linux添加网卡]]></title>
        <id>https://elegancewang.github.io/CPlusPlusNote.github.io/post/linux-tian-jia-wang-qia/</id>
        <link href="https://elegancewang.github.io/CPlusPlusNote.github.io/post/linux-tian-jia-wang-qia/">
        </link>
        <updated>2020-11-03T07:48:52.000Z</updated>
        <content type="html"><![CDATA[<p>Debian/Ubuntu系列</p>
<p>方法一：</p>
<p><code>sudo ifconfig eth0:0 192.168.1.63 up</code></p>
<p>eth0网卡上创建一个叫eth0:0的虚拟网卡,他的地址是:192.168.1.63</p>
<p>如果不想要这个虚拟网卡了,可以使用如下命令删除:</p>
<p><code>sudo ifconfig eth0:0 down</code></p>
<p>方法二：</p>
<p><code>vim /etc/network/interfaces</code></p>
<p>添加并保存例如以下内容：</p>
<pre><code>auto eth0:0

iface eth0:0 inet static

address 192.168.1.63

netmask 255.255.255.0

network 192.168.1.1

broadcast 192.168.1.255
</code></pre>
<p>重启网卡生效</p>
<p><code>/etc/init.d/networking restart</code></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[TC(Traffic Control)]]></title>
        <id>https://elegancewang.github.io/CPlusPlusNote.github.io/post/tc traffic-control/</id>
        <link href="https://elegancewang.github.io/CPlusPlusNote.github.io/post/tc traffic-control/">
        </link>
        <updated>2020-10-27T01:59:10.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<p>Linux中的流量控制</p>
<!-- more -->
<h1 id="1-tc原理">1. TC原理</h1>
<p>Linux操作系统中的流量控制器TC（Traffic Control）用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。<br>
接收包从输入接口进来后，经过流量限制丢弃不符合规定的数据包，由输入多路分配器进行判断选择：</p>
<ul>
<li>如果接收包的目的主机是本主机，那么将该包送给上层处理，否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。</li>
<li>转发块同时也接收本主机上层(TCP、UDP等)产生的包，通过查看路由表，决定所处理包的下一跳。</li>
<li>然后，对包进行排列以便将它们送到输出接口。</li>
</ul>
<p>一般只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。</p>
<h1 id="2-规则">2. 规则</h1>
<h2 id="21-队列queues-和排队规则queueing-disciplines">2.1 队列（Queues） 和排队规则（Queueing Disciplines）</h2>
<p>通过对包进行<strong>排队</strong>（queuing），我们可以决定数据的<strong>发送方式</strong>（the way in which data is SENT）。但理解下面这一点非常重要：我们<strong>只能对发送</strong>（transmit）<strong>的数据进行整形</strong>（shape the data）。</p>
<p><strong>互联网的工作机制</strong>决定了<strong>接收端无法直接控制发送端的行为</strong>。这就像你家的 （实体！）邮箱一样：除非能联系到所有人（告诉他们未经同意不要寄信给你），否则 你无法控制别人寄多少东西过来。😉</p>
<p>但与实际生活不同的是，互联网基于 TCP/IP 协议栈，这多少会带来一些帮助。TCP/IP 无法提前知道两台主机之间的网络带宽，因此开始时它会以越来越快的速度发送数据（慢启 动），直到开始出现丢包，这时它知道已经没有可用空间来存储这些待发送的包了，因此就会 降低发送速度。TCP/IP 的实际工作过程比这个更智能一点，我们后面会再讨论。</p>
<p>这就好比你留下一半的信件在实体邮箱里不取，期望别人知道这个状况后会停止给你寄新的信件。 但不幸的是，<strong>这种方式只对互联网管用，对你的实体邮箱无效</strong> 😃</p>
<p>如果内网有一台路由器，你希望限制某几台主机的下载速度，那你应该找到发送数据到 这些主机的路由器内部接口（inner interface of your router），然后在这些 <strong>路由器内部接口</strong>上做 <strong>整流</strong>（traffic shaping，流量整形）。</p>
<p>此外，还要确保<strong>链路瓶颈</strong>（bottleneck of the link）也在你的控制范围内。例如，如果网 卡是 100Mbps，但路由器的链路带宽是 256Kbps，那首先应该<strong>确保不要发送过多数据给路由器</strong>，因为它可能扛不住。<strong>否则，链路控制和带宽整形的决定权就不在主机侧而到路由器侧了</strong>。要达到限速目的，我们需要对“<strong>发送队列</strong>”有完全的把控（”own the queue”），这里的“发送队列”也就是<strong>整条链路上最慢的一段</strong>（slowest link in the chain）。 幸运的是，大多数情况下这个条件都是能满足的。</p>
<h2 id="22-simple-classless-qdisc简单-不分类排队规则">2.2 Simple， classless qdisc（简单、不分类排队规则）</h2>
<p>如前所述，<strong>排队规则</strong>（queueing disciplines）改变了数据的发送方式。</p>
<p><strong>不分类（或称无类别）排队规则</strong>（classless queueing disciplines）可以对某个网络 接口（interface）上的所有流量进行<strong>无差别整形</strong>。包括对数据进行：</p>
<ul>
<li>重新调度（reschedule）</li>
<li>增加延迟（delay）</li>
<li>丢弃（drop）</li>
</ul>
<p>与 classless qdisc 对应的是 classful qdisc，即<strong>有类别（或称分类别）排队规则</strong>，后者是一个<strong>排队规则中又包含其他排队规则</strong>（qdisc-containing-qdiscs）！😮 先理解了 classless qdisc，才能理解 classful qdisc。<br>
目前最常用的 classless qdisc 是 <code>pfifo_fast qdisc</code>，这也是默认排队规则。 这也解释了为什么这些高级功能如此健壮：本质上来说，它们只不过是“另一个队列”而 已（nothing more than ‘just another queue’）。<br>
每种队列都有自己的优缺点。其中一些可能测试的并不全面。</p>
<h2 id="22-pfifo_fast先入先出队列">2.2 pfifo_fast（先入先出队列）</h2>
<p>如名字所示，这是一个先入先出队列（First In, First Out），因此对所有包都一视同仁。</p>
<p>pfifo_fast 有<strong>三个所谓的 “band”</strong>（可理解为三个队列），编号分别为 0、1、2：</p>
<ul>
<li><strong>每个 band 上分别执行 FIFO 规则</strong>。</li>
<li><strong>如果 band 0 有数据，就不会处理 band 1</strong>；同理，band 1 有数据时， 不会去处理 band 2。</li>
<li>内核会检查<strong>数据包的 TOS 字段</strong>，将**“最小延迟”的包放到 band 0**。</li>
</ul>
<p>不要将 <code>pfifo_fast qdisc</code> 与后面介绍的 <code>PRIO qdisc</code> 混淆，后者是 classful 的！ 虽然二者行为类似，但 <strong><code>pfifo_fast</code> 是无类别</strong>的，这意味你<strong>无法通过 <code>tc</code> 命令向 <code>pfifo_fast</code> 内添加另一个 qdisc。</strong></p>
<h3 id="221-参数与用法">2.2.1 参数与用法</h3>
<p><code>pfifo_fast qdisc</code> 默认配置是写死的（the hardwired default），因此<strong>无法更改</strong>。</p>
<p>下面介绍这份写死的配置是什么样的。</p>
<ul>
<li><strong><code>priomap</code></strong><br>
<code>priomap</code> 决定了<strong>如何将内核设置的 packet priority 映射到 band</strong>。priority 位于包的 TOS 字段：</li>
</ul>
<pre><code>     0     1     2     3     4     5     6     7
  +-----+-----+-----+-----+-----+-----+-----+-----+
  |                 |                       |     |
  |   PRECEDENCE    |          TOS          | MBZ |
  |                 |                       |     |
  +-----+-----+-----+-----+-----+-----+-----+-----+s
</code></pre>
<p>TOS 字段占用 4 个比特，各 bit 含义如下：</p>
<pre><code>  Binary Decimcal  Meaning
  -----------------------------------------
  1000   8         Minimize delay (md)
  0100   4         Maximize throughput (mt)
  0010   2         Maximize reliability (mr)
  0001   1         Minimize monetary cost (mmc)
  0000   0         Normal Service
</code></pre>
<p><code>tcpdump -vv</code> 会打印包的 TOS 字段，其中的 TOS 值对应下面的第一列：</p>
<pre><code class="language-sql">  TOS     Bits  Means                    Linux Priority    Band
  ------------------------------------------------------------
  0x0     0     Normal Service           0 Best Effort     1
  0x2     1     Minimize Monetary Cost   1 Filler          2
  0x4     2     Maximize Reliability     0 Best Effort     1
  0x6     3     mmc+mr                   0 Best Effort     1
  0x8     4     Maximize Throughput      2 Bulk            2
  0xa     5     mmc+mt                   2 Bulk            2
  0xc     6     mr+mt                    2 Bulk            2
  0xe     7     mmc+mr+mt                2 Bulk            2
  0x10    8     Minimize Delay           6 Interactive     0
  0x12    9     mmc+md                   6 Interactive     0
  0x14    10    mr+md                    6 Interactive     0
  0x16    11    mmc+mr+md                6 Interactive     0
  0x18    12    mt+md                    4 Int. Bulk       1
  0x1a    13    mmc+mt+md                4 Int. Bulk       1
  0x1c    14    mr+mt+md                 4 Int. Bulk       1
  0x1e    15    mmc+mr+mt+md             4 Int. Bulk       1
</code></pre>
<p>第二列是对应的十进制表示，第三列是对应的含义。例如，<code>15</code> 表示这个包期望 <code>Minimal Monetary Cost</code> + <code>Maximum Reliability</code> + <code>Maximum Throughput</code> + <code>Minimum Delay</code>。我把这样的包称为“荷兰包”（a ‘Dutch Packet’。荷兰人比较 节俭/抠门，译注）。<strong>第四列是对应到 Linux 内核的优先级；最后一列是 映射到的 band</strong>，从命令行输出看，形式为：</p>
<pre><code>  1, 2, 2, 2, 1, 2, 0, 0 , 1, 1, 1, 1, 1, 1, 1, 1
</code></pre>
<p>例如，priority 4 会映射到 band 1。priomap 还能列出 priority &gt; 7 的那些 不是由 TOS 映射、而是由其他方式设置的优先级。例如，下表列出了<strong>应用（application）是如何设置它们的 TOS 字段</strong>的，来自 RFC 1349（更多信息可<a href="https://tools.ietf.org/html/rfc1349">阅读全文</a>)</p>
<pre><code>  TELNET                   1000           (minimize delay)
  FTP     Control          1000           (minimize delay)
          Data             0100           (maximize throughput)
    
  TFTP                     1000           (minimize delay)
    
  SMTP    Command phase    1000           (minimize delay)
          DATA phase       0100           (maximize throughput)
    
  DNS     UDP Query        1000           (minimize delay)
          TCP Query        0000
          Zone Transfer    0100           (maximize throughput)
    
  NNTP                     0001           (minimize monetary cost)
    
  ICMP    Errors           0000
          Requests         0000 (mostly)
          Responses        &lt;same as request&gt; (mostly)
</code></pre>
<ul>
<li><code>txqueuelen</code><br>
发送队列长度，是一个网络接口（interface）参数，可以用 <code>ifconfig</code> 命令设置。例 如，<code>ifconfig eth0 txqueuelen 10</code>。<br>
<code>tc</code> 命令无法修改这个值。
<h2 id="23-tbftoken-bucket-filter令牌桶过滤器">2.3 TBF（Token Bucket Filter，令牌桶过滤器）</h2>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[WebRTC 环境配置（Windows 平台）]]></title>
        <id>https://elegancewang.github.io/CPlusPlusNote.github.io/post/webrtc-huan-jing-pei-zhi/</id>
        <link href="https://elegancewang.github.io/CPlusPlusNote.github.io/post/webrtc-huan-jing-pei-zhi/">
        </link>
        <updated>2020-09-16T00:40:46.000Z</updated>
        <content type="html"><![CDATA[<p>万事开头难啊，webRTC配置过程中遇到的问题多种多样，有些问题很难搜索到，因此我记录下来供自己参考。</p>
<h1 id="写在前面的话">写在前面的话</h1>
<p>鉴于WebRTC更新太快，所以网上很多编译方法都失效了，所以如果你看到是几年前的文章，就没必要较真了。本文写作时间为2020年9月16日，WebRTC为当前最新版本。请诸君参考。（另，本人所在地为HK，因此不需要稳定的梯子，希望大家能找到稳定的梯子。）</p>
<h1 id="1准备">1.准备</h1>
<p>a) <strong>Win 10 64bit 1909</strong></p>
<p>b) <strong>Visual Studio 2019 Community 16.7.30503.244</strong></p>
<p>c) <strong>Windows 10 SDK</strong><br>
Windows 10.0.19041.1<br>
<img src="https://elegancewang.github.io/CPlusPlusNote.github.io/post-images/1600217267438.png" alt="" loading="lazy"></p>
<p>d) <strong>Python</strong></p>
<p>Python 3.8.5 64bit，编译过程中需添加到Path环境变量</p>
<p>f) <strong>depot_tools</strong><br>
depot_tools是包含下载、编译的相关工具，需要先下载并配置它，才能继续后面的操作。<br>
下载地址:<a href="https://storage.googleapis.com/chrome-infra/depot_tools.zip">depot_tools</a></p>
<p>下载后解压，并将解压好的depot_tools目录添加到path系统环境变量中，如下图所示：</p>
<figure data-type="image" tabindex="1"><img src="https://elegancewang.github.io/CPlusPlusNote.github.io/post-images/1600218587975.png" alt="" loading="lazy"></figure>
<h1 id="2-环境变量配置">2 环境变量配置</h1>
<p>有大量的环境变量需要配置，如果在cmd中set需要保持该窗口。一般在系统环境变量编辑里比较简单方便。<br>
最开始我的设置如下：</p>
<pre><code>DEPOT_TOOLS_UPDATE=0                                 #不更新depot_tools
DEPOT_TOOLS_WIN_TOOLCHAIN=0                          #编译时使用本机VS工具链
GYP_MSVS_VERSION = 2019                              #指定VS版本
GYP_MSVS_OVERRIDE_PATH = C:\Program Files (x86)\Microsoft Visual Studio\2019\Community  #vs安装路径，替换成自己的
GYP_GENERATORS=msvs-ninja,ninja                      #使用ninja编译

</code></pre>
<p><strong>Error</strong><br>
depot_tools/python3_bin_reldir.txt: No such file or directory<br>
failed to determine Python version</p>
<p>我认为是环境变量阻止了其在Windows下的引导，因此删去<code>DEPOT_TOOLS_UPDATE=0</code> 的环境变量即可.</p>
<h1 id="3获取webrtc源码">3.获取WebRTC源码</h1>
<p>接着执行<code>gclient</code>命令，安装编译需要用到的一些工具，比如git以及python。</p>
<p>其他的环境变量我们已经在前文设置，无需通过cmd进行设置，这是为了我自己的方便，如果对于环境变量有要求，请在cmd自行设置，例：</p>
<pre><code>set vs2019_install=C:\Program Files (x86)\Microsoft Visual Studio\2019\Community
set GYP_MSVS_OVERRIDE_PATH=C:\Program Files (x86)\Microsoft Visual Studio\2019\Community 
set GYP_GENERATORS=msvs-ninja,ninja
# 告诉depot_tools使用我们本机的VS进行编译
set DEPOT_TOOLS_WIN_TOOLCHAIN=0

</code></pre>
<p>然后cd到要放源码的地方（要遵守前面说的磁盘要求），执行：</p>
<pre><code>mkdir webrtc-checkout
cd webrtc-checkout
fetch --nohooks webrtc
gclient sync

</code></pre>
<p>这一过程的时间比较长，包括源码以及一些测试的音视频文件资源等。如果没有稳定快速的梯子需要等待较长时间。</p>
<p>如果因为网络等原因中断了，就再执行<code>gclient sync</code>。如果这一步一直卡着不动，可以执行<code>ctrl+c</code>，然后执行<code>gclient sync</code>。</p>
<h1 id="4编译">4.编译</h1>
<p>生成VS2019工程文件：</p>
<pre><code>cd src
gn gen --ide=vs out/Default

</code></pre>
<p>可以在src\out\Default\ 下得到 all.sln解决方案文件。</p>
<p>如果不想使用默认编译参数，可以使用gn args out/Default --list查看当前编译参数，通过类似如下方式设置：<br>
<code>gn gen --ide=vs out/Default --args=“use_rtti=true is_clang=false rtc_build_tools=false rtc_include_tests=false rtc_build_examples=false”</code></p>
<p>接着执行编译命令：</p>
<pre><code>ninja -C out/Default
</code></pre>
<h1 id="代码更新">代码更新</h1>
<pre><code>git checkout master
git pull origin master
gclient sync

</code></pre>
<h1 id="引用webrtc库">引用WebRTC库</h1>
<p>WebRTC编译后会在src\out\Default\obj目录下生成整个WebRTC工程的静态库：webrtc.lib，链接下这个就可以了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++学习笔记]]></title>
        <id>https://elegancewang.github.io/CPlusPlusNote.github.io/post/learnC/</id>
        <link href="https://elegancewang.github.io/CPlusPlusNote.github.io/post/learnC/">
        </link>
        <updated>2020-07-22T06:01:37.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<h1 id="chapter-8">Chapter 8</h1>
<p>指针、引用<br>
<strong>指针</strong>—— 存储内存地址<br>
<strong>变量</strong> ——占用空间、声明、初始化（否则值为随机）</p>
<h2 id="81-运算符">8.1 运算符</h2>
<h3 id="11-使用引用运算符获取变量地址">1.1 使用引用运算符（&amp;）获取变量地址</h3>
<p>e.g. Varname —— 变量<br>
&amp;Varname —— 存储该变量内存地址</p>
<h3 id="12-使用接触引用运算符">1.2   使用接触引用运算符（*）</h3>
<p>以此访问包含地址的值<br>
e.g. 有合法指针——pData<br>
那么该指针地址处存储的值可用 *pData 来获取</p>
<h3 id="13-sizeof">1.3 sizeof()</h3>
<pre><code>用于指针时，结果取决于编译器及针对的操作系统，与指针变量无关。
</code></pre>
<h2 id="82-动态内存分配">8.2 动态内存分配</h2>
<h3 id="1-关键字new-delete-动态分配和释放内存">1. 关键字new &amp; delete 动态分配和释放内存</h3>
<p><strong>new分配新的内存块，若成功，返回一个指针，指向新分配的内存，否则引发异常（使用时，指定数据类型分配内存）</strong><br>
Type* Pointer = new Type;<br>
Type* Pointer = new Type[ Num Elements ];<br>
e.g.</p>
<pre><code class="language-cpp">int * pNumber = new int;
int * pNumber = new int[ 10 ];
</code></pre>
<p><em>注 ：请求分配内存并不保证请求能够得到满足，取决于系统状态机内存资源的可用性。</em><br>
<strong>使用关键字 <strong>new</strong> 分配的内存最终使用对应的关键字 <strong>delete</strong> 释放</strong><br>
Type* Pointer = new Type;<br>
delete Pointer;<br>
或<br>
Type* Pointer = new Type[ Num Elements ];<br>
delete [] Pointer;</p>
<h3 id="2-递增-递减-运算符作用于指针的结果">2. 递增（++）、递减（--）运算符作用于指针的结果</h3>
<p>对指针执行递增 / 递减， 指向的是内存中相邻的值，而不是相邻的字节（除非值的长度刚好1字节，例如char）<br>
Type * pType = Address;<br>
++pType --&gt; Adress + sizeof( Type )</p>
<h3 id="3-关键字const作用于指针">3. 关键字const作用于指针</h3>
<p>const指针有三种：<br>
a ）指针直线的数据为常量，不可修改，但可以修改包含的地址（指针可指向其他地址）<br>
b ) 指针包含地址为常量，不能修改，可以修改数据<br>
c ) 最为严格的情况，地址及值均为常量，均不可修改，但更易于维护。</p>
<h3 id="4-将指针传递给函数">4. 将指针传递给函数</h3>
<p><em>将内存空间传递给函数，其中可包含值，可包含结果</em><br>
注意传入的数据是否需要修改或者经过计算。</p>
<h3 id="5-数组与指针">5. 数组与指针</h3>
<p>可以将数组变量赋值给类型相同的指针。</p>
<h2 id="83-常见错误">8.3 常见错误</h2>
<h3 id="1内存泄露">1.内存泄露</h3>
<p>常见原因是未正确释放内存</p>
<h3 id="2指向无效的内存单元">2.指向无效的内存单元</h3>
<p>无效指针</p>
<h3 id="3悬浮指针">3.悬浮指针</h3>
<p><em>亦可称之为迷途/失控指针</em><br>
为便面此类问题，初始化/释放指针后将其置为NULL，并在解除引用前（使用关键字 ** * **）检查其是否有效。</p>
<h2 id="84-编程实践">8.4 编程实践</h2>
<p>Step1 初始化指针变量<br>
step2 使用前判断指针是否为NULL——&gt;异常处理，在new（创建指针）失败时妥善退出<br>
Step3 仅在其有效时使用<br>
Step4 new之后必用关键字delete释放内存，且delete后不再访问该指针</p>
<h2 id="85-引用">8.5 引用（&amp;）</h2>
<p>引用是变量的别名（相应变量的的另一个名字，指向相同的内存单元）</p>
<pre><code class="language-cpp">VarType Original = Value;
VarType &amp; ReferenceVariable = Original;

</code></pre>
<h3 id="1引用的用处">1.引用的用处</h3>
<p>避免了传参时因参数占用内存过大，复制时也会开销很大。</p>
<h3 id="2-const-用于引用">2. const 用于引用</h3>
<p>禁止通过引用修改其指向的变量的值。</p>
<p>const引用参数不能作用于左值</p>
<h3 id="3-按引用向函数传递参数">3. 按引用向函数传递参数</h3>
<p>可避免将形参复制给形参，从而极大提高性能。然而，让被调用的函数直接使用调用函数栈时，确保被调用函数不能修改调用函数中的变量很重要。因此，可将引用声明为const</p>
<h1 id="chapter-9-类和对象">Chapter 9 类和对象</h1>
<h2 id="91-类和对象简述">9.1 类和对象简述</h2>
<h3 id="1-类的声明">1.  类的声明</h3>
<p>关键字 <strong>class</strong> 依次包含类名、成员属性、方法（属于类成员的函数）及结尾分号（<strong>;</strong>）<br>
即通过关键字<strong>class</strong>创建数据类型，并<mark>封装</mark>属性。</p>
<p>&quot;封装&quot; 将数据及使用它们的方法进行逻辑编组</p>
<h3 id="2实例化对象">2.实例化对象</h3>
<p>在使用时，根据类实例化一个对象，通过对象访问成员方法及属性。</p>
<pre><code class="language-cpp">class Human
{
    string Name;
    string DateofBirth;

    void Talk( string TexttoTalk );
};
</code></pre>
<p>那么实例化一个对象Tom</p>
<pre><code class="language-cpp">//方法一
Human Tom;

//方法二
Human* pAnotherHuman = new Human( );
delete pAnotherHuman;
</code></pre>
<h3 id="3通过句点运算符访问成员">3.通过句点运算符（.）访问成员</h3>
<p>句点运算符（.）用于访问对象的属性。这同样适用于方法。</p>
<pre><code class="language-cpp">
Human Tom;

Tom. DateofBirth = &quot;1970&quot; ;

Huamn* pTom = new Human();
(*pTom).IntroduceSelf();//使用间接运算符（*）获取对象，再使用句点运算符来访问成员。
</code></pre>
<h3 id="4-使用指针运算符访问成员-">4. 使用指针运算符访问成员（-&gt;）</h3>
<p>若对象使用new实例化或有指向对象的指针，则可以使用 **指针运算符（-&gt;）**来访问成员属性和方法。</p>
<h1 id="chapter-11">Chapter 11</h1>
<p>**</p>
<h2 id="111-多态基础">11.1.  多态基础</h2>
<h3 id="11">1.1</h3>
<p><strong>类之间存在层次结构，类是通过继承相关联时，通过多态来表示。</strong><br>
多态意味着调用成员函数时，根据函数的对象类型执行不同的方法。（而不是调用预设的基类中的函数方法），即表现实际类型。</p>
<h3 id="12">1.2</h3>
<p><strong>使用虚函数实现多态行为</strong></p>
<p>将基类中方法声明为虚函数，使用关键字 virtual， 确保编译器调用覆盖版本（子类、派生类）。</p>
<p><mark>多态行为</mark> 将派生类对象视为几类对象，并执行派生类的函数（方法）实现。</p>
<h3 id="13-为何需要虚构造函数">1.3 为何需要<mark>虚构造函数</mark></h3>
<p>除了需要使用派生类对象，还需要避免计算机资源未释放、内存泄露等问题（即将实例化的派生类对象，将其值赋给基类当做指针，并通过该指针调用 delete， 将不会调用派生类的析构函数）</p>
<pre><code>												**⬇**
</code></pre>
<p>那么将析构函数声明为虚函数，确保通过基类指针调用delete时，不会调用派生类析构函数</p>
<pre><code class="language-cpp">class Base
{
public:
	virtual ~Base()		
};

</code></pre>
<h3 id="auto-关键字">auto 关键字</h3>
<p>利用auto关键字，通过编译器检查变量的初始值，并将该变量类型设置为该返回值的类型。能够简化编码工作。</p>
<pre><code class="language-cpp">std::vector&lt;int&gt; MyNumbers;
	//常规
	for (vector&lt;int&gt;::const_iterator Iterator =  MyNumbers.begin(); 
		Iterator &lt; MyNumbers.end(); ++Iterator )
	std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;;
	//利用auto关键字
		for (auto Iterator =  MyNumbers.begin(); 
		Iterator &lt; MyNumbers.end(); ++Iterator )
	std::cout &lt;&lt; * Iterator&lt;&lt; &quot; &quot;;
</code></pre>
<p>**</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于]]></title>
        <id>https://elegancewang.github.io/CPlusPlusNote.github.io/post/about/</id>
        <link href="https://elegancewang.github.io/CPlusPlusNote.github.io/post/about/">
        </link>
        <updated>2019-01-25T11:09:48.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>欢迎来到我的小站呀，很高兴遇见你！🤝 #KTBFFH 💙 CHELSEA</p>
</blockquote>
<h2 id="关于本站">🏠 关于本站</h2>
<p>重新开始学习计算机语言，</p>
<h2 id="博主是谁">👨‍💻 博主是谁</h2>
<h2 id="兴趣爱好">⛹ 兴趣爱好</h2>
<p>CHELSEA、DOTA</p>
<h2 id="联系我呀">📬 联系我呀</h2>
<p>githubwrz@163.com</p>
]]></content>
    </entry>
</feed>